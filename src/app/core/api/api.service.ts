/**
 * Walmart Kiosk Experience
 * Implements all interactions with the Product-Finder API
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Injectable } from '@angular/core';
import { Http, Headers, URLSearchParams } from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response } from '@angular/http';

import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models from './model/models';
import { environment } from './../../../environment/environment';

/* tslint:disable:no-unused-variable member-ordering */

@Injectable()
export class APIService {
	protected basePath: string = environment.apiUrl;
	public defaultHeaders: Headers = new Headers();

	constructor(
		protected http: Http
	) {}

	public getExhibitData(): Observable<models.AcquisitionResponse> {
		return this.getExhibitDataWithHttpInfo()
			.map((response: Response) => {
				if (response.status === 204) {
					return undefined;
				} else {
					return response.json();
				}
			});
	}

	private getExhibitDataWithHttpInfo(): Observable<Response> {
		const path = this.basePath + `/items.aspx`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		headers.set('Content-Type', 'application/json');

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers
		});

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Extends object by coping non-existing properties.
	 * @param objA object to be extended
	 * @param objB source object
	 */
	private extendObj (objA, objB) {
		for (let key in objB) {
			if (objB.hasOwnProperty(key)) {
				objA[key] = objB[key];
			}
		}
		return objA;
	}

	/**
	 *
	 * Access a url through the proxy
	 * @param url The url to call through the proxy
	 */
	public getProxy(url?: string, extraHttpRequestParams?: any): Observable < models.DefaultResponse > {
		return this.getProxyWithHttpInfo(url, extraHttpRequestParams)
			.map((response: Response) => {
				if (response.status === 204) {
					return undefined;
				} else {
					return response.json();
				}
			});
	}

	/**
	 *
	 * Send an email to a customer
	 * @param params Parameters to pass to the ENS Service to facilitate an email
	 */
	public sendEmail(params: string, extraHttpRequestParams?: any): Observable < models.DefaultResponse > {
		return this.sendEmailWithHttpInfo(params, extraHttpRequestParams)
			.map((response: Response) => {
				if (response.status === 204) {
					return undefined;
				} else {
					return response.json();
				}
			});
	}

	/**
	 *
	 * Send an analytics event
	 * @param params Parameters to pass to analytics service
	 */
	public sendEvent(params: models.AnalyticsEventParams, extraHttpRequestParams?: any): Observable < models.DefaultResponse > {
		return this.sendEventWithHttpInfo(params, extraHttpRequestParams)
			.map((response: Response) => {
				if (response.status === 204) {
					return undefined;
				} else {
					return response.json();
				}
			});
	}

	/**
	 *
	 * Send an analytics page view
	 * @param params Parameters to pass to analytics service
	 */
	public sendPageview(params: models.AnalyticsPageParams, extraHttpRequestParams?: any): Observable < models.DefaultResponse > {
		return this.sendPageviewWithHttpInfo(params, extraHttpRequestParams)
			.map((response: Response) => {
				if (response.status === 204) {
					return undefined;
				} else {
					return response.json();
				}
			});
	}

	/**
	 *
	 * Send a text to a customer
	 * @param params Parameters to pass to the ENS Service to facilitate a text message
	 */
	public sendText(params: string, extraHttpRequestParams?: any): Observable < models.DefaultResponse > {
		return this.sendTextWithHttpInfo(params, extraHttpRequestParams)
			.map((response: Response) => {
				if (response.status === 204) {
					return undefined;
				} else {
					return response.json();
				}
			});
	}

	/**
	 *
	 * Send a timing analytics event.  Used to track latency for external calls
	 * @param params Parameters to pass to analytics service
	 */
	public sendTiming(params: models.AnalyticsTimingParams, extraHttpRequestParams?: any): Observable < models.DefaultResponse > {
		return this.sendTimingWithHttpInfo(params, extraHttpRequestParams)
			.map((response: Response) => {
				if (response.status === 204) {
					return undefined;
				} else {
					return response.json();
				}
			});
	}

	/**
	 *
	 * Send an error/crash report.  Used for remote debugging and optimization.
	 * @param params Parameters to pass to the crash reporting service
	 */
	public sendReport(params: any, extraHttpRequestParams?: any): Observable < models.DefaultResponse > {
		return this.sendReportWithHttpInfo(params, extraHttpRequestParams)
			.map((response: Response) => {
				if (response.status === 204) {
					return undefined;
				} else {
					return response.json();
				}
			});
	}

	/**
	 *
	 * Loads all the default configuration and variables
	 * @param category The application category to load values
	 */
	public getDefaultsWithHttpInfo(segments: string[], category_id?: string, extraHttpRequestParams?: any): Observable<Response> {
		const path = this.basePath + `/defaults`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

		if (segments !== undefined) {
			queryParameters.set('segments', <any>segments);
		}

		if (category_id !== undefined) {
			queryParameters.set('category_id', <any>category_id);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}


	/**
	 *
	 * Find items with various filters
	 * @param itemQuery Query body
	 */
	public findWithHttpInfo(itemQuery: models.ItemQuery, extraHttpRequestParams?: any): Observable<Response> {
		const path = this.basePath + `/items`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'itemQuery' is not undefined or undefined
		if (itemQuery === undefined || itemQuery === undefined) {
			throw new Error('Required parameter itemQuery was undefined or undefined when calling find.');
		}


		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		headers.set('Content-Type', 'application/json');

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Post,
			headers: headers,
			body: itemQuery === undefined ? '' : JSON.stringify(itemQuery), // https://github.com/angular/angular/issues/10612
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Find an item by a specific id
	 * @param id The id of an item
	 * @param type The type of id being submitted
	 */
	public findOneWithHttpInfo(id: number, storeId?: string, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + `/items/${id}`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'id' is not undefined or undefined
		if (id === undefined) {
			throw new Error('Required parameter id was undefined or undefined when calling findOne.');
		}
		if (storeId !== undefined) {
			queryParameters.set('store_id', < any > storeId);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	public getSearchQuerySuggestionsWithHttpInfo(
		query: string,
		categoryId: string,
		extraHttpRequestParams?: any
	): Observable<Response> {
		if (query === undefined) {
			query = '';
		}
		const path = this.basePath + `/items/search/${query}`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

		if (!categoryId) {
			categoryId = '0';
		}

		if (categoryId) {
			queryParameters.set('category_id', <any> categoryId);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Get extra details for an item that has been partially loaded elsewhere
	 * @param id The id (USItemId) of an item
	 * @param storeId The store id to perform the query on (required for valid pricing information)
	 * @param segments The segments you want returned
	 */
	public getItemExtraWithHttpInfo(
		id: number,
		storeId: number,
		wupc: string,
		segments?: string,
		extraHttpRequestParams?: any
	): Observable<Response> {
		const path = this.basePath + `/items/${id}/extra`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

		// verify required parameter 'id' is not undefined or undefined
		if (id === undefined || id === undefined) {
			throw new Error('Required parameter id was undefined or undefined when calling getItemDetails.');
		}
		// verify required parameter 'storeId' is not undefined or undefined
		if (storeId === undefined || storeId === undefined) {
			throw new Error('Required parameter storeId was undefined or undefined when calling getItemDetails.');
		}
		if (storeId !== undefined) {
			queryParameters.set('store_id', <any>storeId);
		}
		if (wupc !== undefined) {
			queryParameters.set('wupc', <any>wupc);
		}
		if (segments !== undefined) {
			queryParameters.set('segments', <any>segments);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Find the aisle location for a given item in a given store
	 * @param id The id of an item
	 * @param storeId The store id to perform the query on
	 */
	public getItemLocationWithHttpInfo(id: number, storeId: number, extraHttpRequestParams?: any): Observable<Response> {
		const path = this.basePath + `/items/${id}/location`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

		// verify required parameter 'id' is not undefined or undefined
		if (id === undefined) {
			throw new Error('Required parameter id was undefined or undefined when calling getItemLocation.');
		}
		// verify required parameter 'storeId' is not undefined or undefined
		if (storeId === undefined) {
			throw new Error('Required parameter storeId was undefined or undefined when calling getItemLocation.');
		}
		if (storeId !== undefined) {
			queryParameters.set('store_id', <any>storeId);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Find related items for a specific item
	 * @param id The id of an item
	 * @param storeId The store id to perform the query on
	 */
	public getItemRelatedWithHttpInfo(id: number, storeId: number, extraHttpRequestParams?: any): Observable<Response> {
		const path = this.basePath + `/items/${id}/related`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'id' is not undefined or undefined
		if (id === undefined) {
			throw new Error('Required parameter id was undefined or undefined when calling getItemRelated.');
		}
		// verify required parameter 'storeId' is not undefined or undefined
		if (storeId === undefined) {
			throw new Error('Required parameter storeId was undefined or undefined when calling getItemRelated.');
		}
		if (storeId !== undefined) {
			queryParameters.set('store_id', <any>storeId);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Find the reviews for a specific item
	 * @param id The id of an item
	 */
	public getItemReviewsWithHttpInfo(
		id: number,
		numReviews?: number,
		offset?: number,
		rating?: number,
		sort?: string,
		extraHttpRequestParams?: any
	): Observable<Response> {
		const path = this.basePath + `/items/${id}/reviews`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'id' is not undefined or undefined
		if (id === undefined) {
			throw new Error('Required parameter id was undefined or undefined when calling getItemReviews.');
		}

		if (numReviews !== undefined) {
			queryParameters.set('num_reviews', <any>numReviews);
		}

		if (offset !== undefined) {
			queryParameters.set('offset', <any>offset);
		}

		if (rating !== undefined) {
			queryParameters.set('rating', <any>rating);
		}

		if (sort !== undefined) {
			queryParameters.set('sort', <any>sort);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	public getCategoriesWithHttpInfo(catId: string): Observable<Response> {
		const path = this.basePath + `/defaults/categories`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON());

		if (catId === undefined) {
			throw new Error('Required parameter catId was undefined or undefined when calling getCategories.');
		}
		if (catId !== undefined) {
			queryParameters.set('category_id', <any>catId);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Access a url through the proxy
	 * @param url The url to call through the proxy
	 */
	public getProxyWithHttpInfo(url?: string, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + `/proxy`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		if (url !== undefined) {
			queryParameters.set('url', < any > url);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Find reviews for an item
	 * @param id The USItemId of an item
	 */
	public getReviewsWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + `/items/reviews`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'id' is not undefined or undefined
		if (id === undefined) {
			throw new Error('Required parameter id was undefined or undefined when calling getReviews.');
		}
		if (id !== undefined) {
			queryParameters.set('id', < any > id);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Get,
			headers: headers,
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * POST request through the proxy
	 * @param url The url to call through the proxy
	 * @param params The body params to pass through the POST request
	 */
	public postProxyWithHttpInfo(url?: string, params?: string, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + `/proxy`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		if (url !== undefined) {
			queryParameters.set('url', < any > url);
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		headers.set('Content-Type', 'application/json');

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Post,
			headers: headers,
			body: params === undefined ? '' : JSON.stringify(params), // https://github.com/angular/angular/issues/10612
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Send an email to a customer
	 * @param params Parameters to pass to the ENS Service to facilitate an email
	 */
	public sendEmailWithHttpInfo(params: string, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + `/send/email`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'params' is not undefined or undefined
		if (params === undefined || params === undefined) {
			throw new Error('Required parameter params was undefined or undefined when calling sendEmail.');
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		headers.set('Content-Type', 'application/json');

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Post,
			headers: headers,
			body: params === undefined ? '' : JSON.stringify(params), // https://github.com/angular/angular/issues/10612
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Send an analytics event
	 * @param params Parameters to pass to analytics service
	 */
	public sendEventWithHttpInfo(params: models.AnalyticsEventParams, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + `/analytics/event`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'params' is not undefined or undefined
		if (params === undefined) {
			throw new Error('Required parameter params was undefined or undefined when calling sendEvent.');
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		headers.set('Content-Type', 'application/json');

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Post,
			headers: headers,
			body: params === undefined ? '' : JSON.stringify(params), // https://github.com/angular/angular/issues/10612
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Send an analytics page view
	 * @param params Parameters to pass to analytics service
	 */
	public sendPageviewWithHttpInfo(params: models.AnalyticsPageParams, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + `/analytics/pageview`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'params' is not undefined or undefined
		if (params === undefined || params === undefined) {
			throw new Error('Required parameter params was undefined or undefined when calling sendPageview.');
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		headers.set('Content-Type', 'application/json');

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Post,
			headers: headers,
			body: params === undefined ? '' : JSON.stringify(params), // https://github.com/angular/angular/issues/10612
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Send a text to a customer
	 * @param params Parameters to pass to the ENS Service to facilitate a text message
	 */
	public sendTextWithHttpInfo(params: string, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + `/send/text`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'params' is not undefined or undefined
		if (params === undefined || params === undefined) {
			throw new Error('Required parameter params was undefined or undefined when calling sendText.');
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		headers.set('Content-Type', 'application/json');

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Post,
			headers: headers,
			body: params === undefined ? '' : JSON.stringify(params), // https://github.com/angular/angular/issues/10612
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	/**
	 *
	 * Send a timing analytics event.  Used to track latency for external calls
	 * @param params Parameters to pass to analytics service
	 */
	public sendTimingWithHttpInfo(params: models.AnalyticsTimingParams, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + `/analytics/timing`;

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
		// verify required parameter 'params' is not undefined or undefined
		if (params === undefined || params === undefined) {
			throw new Error('Required parameter params was undefined or undefined when calling sendTiming.');
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		headers.set('Content-Type', 'application/json');

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Post,
			headers: headers,
			body: params === undefined ? '' : JSON.stringify(params), // https://github.com/angular/angular/issues/10612
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}

	public sendReportWithHttpInfo(params: string, extraHttpRequestParams?: any): Observable < Response > {
		const path = this.basePath + '/reporting/sendReport';

		let queryParameters = new URLSearchParams();
		let headers = new Headers(this.defaultHeaders.toJSON());
		// verify required parameter 'params' is not undefined or undefined
		if (params === undefined || params === undefined) {
			throw new Error('Required parameter params was undefined or undefined when calling sendTiming.');
		}

		// to determine the Content-Type header
		let consumes: string[] = [
			'application/json'
		];

		// to determine the Accept header
		let produces: string[] = [
			'application/json'
		];

		headers.set('Content-Type', 'application/json');

		let requestOptions: RequestOptionsArgs = new RequestOptions({
			method: RequestMethod.Post,
			headers: headers,
			body: params === undefined ? '' : JSON.stringify(params), // https://github.com/angular/angular/issues/10612
			search: queryParameters
		});

		// https://github.com/swagger-api/swagger-codegen/issues/4037
		if (extraHttpRequestParams) {
			requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
		}

		return this.http.request(path, requestOptions);
	}
}
